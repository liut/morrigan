package web

import (
	"time"

	"github.com/liut/morrigan/pkg/models/aigc"
	"github.com/liut/morrigan/pkg/services/stores"
	"github.com/sashabaranov/go-openai"
)

const (
	// tokens bytes
	historyLimitToken = 50 * 1024

	esDone = "[DONE]"

	dftSystemMsg = "You are a helpful assistant."
	dftToolsMsg  = "You will select the appropriate tool based on the user's question and call the tool to solve the problem. If the tool requires parameters, you must extract them from the user's question. Note that it is important to clearly distinguish between read and write operations. If a write operation is required by the tool, it must be explicitly stated in the user's question for writing purposes (such as adding, creating, appending, modifying, etc.), and all necessary parameters for the tool must be included in the user's question before calling; otherwise, treat it as a regular read operation or Q&A."
	welcomeText  = "Hello, I am your virtual assistant. How can I help you?"
)

func thisMoment() string {
	return "Current Date: " + time.Now().Format("2006-01-02 15:04")
}

type ChatCompletionMessage = openai.ChatCompletionMessage

type CompletionRequest struct {
	openai.CompletionRequest

	ConversationID string `json:"csid"`

	cs stores.Conversation
}

type ChatCompletionRequest struct {
	openai.ChatCompletionRequest

	isSSE bool
	cs    stores.Conversation
	hi    *aigc.HistoryItem

	// for response
	chunkIdx int
}

type ChatRequest struct {
	Prompt          string `json:"prompt"`
	ConversationID  string `json:"csid"`
	ParentMessageID string `json:"pmid"`
	Regenerate      bool   `json:"regen"`
	Stream          bool   `json:"stream"`
	Full            bool   `json:"full,omitempty"`

	// deprecated: for github.com/Chanzhaoyu/chatgpt-web only
	Options struct {
		ConversationId string `json:"conversationId,omitempty"`
	} `json:"options,omitempty"`
}

func (z *ChatRequest) GetConversionID() string {
	if z.ConversationID != "" {
		return z.ConversationID
	}
	if z.Options.ConversationId != "" {
		return z.Options.ConversationId
	}
	return ""
}

type ChatCompletionChoice struct {
	FinishReason string `json:"finishReason,omitempty"`
	Index        int    `json:"index"`
	Text         string `json:"text"`
}
type ConversationResponse struct {
	ConversationID  string `json:"csid"`
	ParentMessageID string `json:"pmid"`
	Detail          struct {
		Choices []ChatCompletionChoice `json:"choices"`

		Created int64  `json:"created"`
		ID      string `json:"id"`
		Model   string `json:"model"`
		Object  string `json:"object"`
		Usage   struct {
			CompletionTokens int `json:"completionTokens"`
			PromptTokens     int `json:"promptTokens"`
			TotalTokens      int `json:"totalTokens"`
		} `json:"usage"`
	} `json:"detail"`
}

type ChatMessage struct {
	ID    string `json:"id,omitempty"`
	Delta string `json:"delta,omitempty"`
	Text  string `json:"text,omitempty"`
	Role  string `json:"role,omitempty"`
	Name  string `json:"name,omitempty"`

	// For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls.
	ToolCalls []ToolCall `json:"tool_calls,omitempty"`

	// For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool.
	ToolCallID string `json:"tool_call_id,omitempty"`

	FinishReason string `json:"finishReason,omitempty"`

	ConversationID string `json:"csid,omitempty"`
}

type ChatResponse struct {
	answer    string
	toolCalls []ToolCall
	usage     *openai.Usage
}

type CompletionMessage struct {
	ID    string `json:"id,omitempty"`
	Delta string `json:"delta,omitempty"`
	Text  string `json:"text,omitempty"`
	Time  int64  `json:"ts,omitempty"`

	FinishReason string `json:"finishReason,omitempty"`
}

type ToolCall = openai.ToolCall

const (
	ToolNameKBSearch = "kb_search"
	ToolNameKBCreate = "kb_create"
)
